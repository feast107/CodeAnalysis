<#@ template language="C#" #>
<#@ import namespace="System.Collections.Generic" #>
<#
    const string NameSpace = "Microsoft.CodeAnalysis";
    const string Using = """
                         using System.Linq;
                         """;
    const string String = "global::System.String";
    const string Bool = "global::System.Boolean";
    const string SyntaxNode = "global::Microsoft.CodeAnalysis.SyntaxNode";
    const string IEnumerable = "global::System.Collections.Generic.IEnumerable";
    const string IMethodSymbol = "global::Microsoft.CodeAnalysis.IMethodSymbol";
    const string SemanticModel = "global::Microsoft.CodeAnalysis.SemanticModel";
    const string SyntaxKind = "global::Microsoft.CodeAnalysis.CSharp.SyntaxKind";
    const string TypeSyntax = "global::Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax";
    const string AttributeSyntax = "global::Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax";
    const string CompilationUnitSyntax = "global::Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax";
    const string LiteralExpressionSyntax = "global::Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax";
    const string TypeOfExpressionSyntax = "global::Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax";
    const string AttributeArgumentSyntax = "global::Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax";
    const string MemberDeclarationSyntax = "global::Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax";
    const string LambdaExpressionSyntax = "global::Microsoft.CodeAnalysis.CSharp.Syntax.LambdaExpressionSyntax";
    const string BaseParameterSyntax = "global::Microsoft.CodeAnalysis.CSharp.Syntax.BaseParameterSyntax";
    const string StatementSyntax = "global::Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax";
    const string CancellationToken = "global::System.Threading.CancellationToken";
    const string NotSupported = "global::System.NotSupportedException";
    const string SyntaxFactory = "global::Microsoft.CodeAnalysis.CSharp.SyntaxFactory";
    const string ClassName = "Syntax";
    const string NameSyntax = "Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax";
    const string NameSpaceDeclarationSyntax = "Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax";
    const string ClassDeclarationSyntax = "Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax";
    
    var methods = new List<(string name,Func<string,string> text)>
    {
        ("GetAllAttributes",
            x=>$$"""
            public static {{IEnumerable}}<{{AttributeSyntax}}> {{x}}(this {{SyntaxNode}} syntax)
            {
                var attributeLists = syntax switch
                {
                    {{CompilationUnitSyntax}} compilationUnitSyntax     => compilationUnitSyntax.AttributeLists,
                    {{MemberDeclarationSyntax}} memberDeclarationSyntax => memberDeclarationSyntax.AttributeLists,
                    {{LambdaExpressionSyntax}} lambdaExpressionSyntax   => lambdaExpressionSyntax.AttributeLists,
                    {{BaseParameterSyntax}} baseParameterSyntax         => baseParameterSyntax.AttributeLists,
                    {{StatementSyntax}} statementSyntax                 => statementSyntax.AttributeLists,
                    _                                                                                            => throw new {{NotSupported}}($"{syntax.GetType()} has no attribute")
                };
                return attributeLists.SelectMany(attributeListSyntax => attributeListSyntax.Attributes);
            }
            """),
        ("GetSpecifiedAttributes",
            x=>$$"""
              public static {{IEnumerable}}<{{AttributeSyntax}}> {{x}}(this {{SyntaxNode}} syntax, 
                  {{SemanticModel}} semanticModel, 
                  {{String}} fullAttributeName, 
                  {{CancellationToken}} cancellationToken = default ({{CancellationToken}}))
              {
                  foreach (var attributeSyntax in syntax.GetAllAttributes())
                  {
                      if(cancellationToken.IsCancellationRequested)
                          yield break;
                      if (semanticModel.GetSymbolInfo(attributeSyntax, cancellationToken).Symbol is not {{IMethodSymbol}} attributeSymbol)
                          continue;
              
                      string attributeName = attributeSymbol.ContainingType.ToDisplayString();
              
                      if (attributeName == fullAttributeName)
                          yield return attributeSyntax;
                  }
              }
              """),
        ("GetSpecifiedAttribute",
            x=>$$"""
              public static {{AttributeSyntax}}? {{x}}(this {{SyntaxNode}} syntax, 
                  {{SemanticModel}} semanticModel, 
                  {{String}} fullAttributeName,
                  {{CancellationToken}} cancellationToken = default ({{CancellationToken}}))
              {
                  foreach (var attributeSyntax in syntax.GetSpecifiedAttributes(semanticModel, fullAttributeName, cancellationToken))
                  {
                      return attributeSyntax;
                  }
                  return null;
              }
              """),
        ("HasSpecifiedAttribute",
            x=>$$"""
              public static {{Bool}} {{x}}(this {{MemberDeclarationSyntax}} syntax, 
                  {{SemanticModel}} semanticModel, 
                  {{String}} fullAttributeName)
              {
                  return syntax.GetSpecifiedAttribute(semanticModel, fullAttributeName) is not null;
              }
              """),
        ("GetArgumentString",
            x=>$$"""
              public static {{String}}? {{x}}(this {{AttributeArgumentSyntax}} syntax)
              {
                  if (syntax.Expression is not {{LiteralExpressionSyntax}} literalExpressionSyntax) return null;
                  if (!literalExpressionSyntax.IsKind({{SyntaxKind}}.StringLiteralExpression)) return null;
                  return literalExpressionSyntax.Token.ValueText;
              }
              """),
        ("GetArgumentType",
            x=>$$"""
              public static {{TypeSyntax}}? {{x}}(this {{AttributeArgumentSyntax}} syntax)
              {
                  if (syntax.Expression is not {{TypeOfExpressionSyntax}} typeOfExpression) return null;
                  return typeOfExpression.Type;
              }
              """),
        ("ToNameSyntax",
            x=>$$"""
              public static {{NameSyntax}} {{x}}(this string text, int offset = 0, bool consumeFullText = true)
              {
                  return {{SyntaxFactory}}.ParseName(text, offset, consumeFullText);
              }
              """),
        ("ToNamespaceDeclaration",
            x=>$$"""
              public static {{NameSpaceDeclarationSyntax}} {{x}}(this {{NameSyntax}} syntax)
              {
                  return {{SyntaxFactory}}.NamespaceDeclaration(syntax);
              }
              """),
        ("ToClassDeclaration",
            x=>$$"""
              public static {{ClassDeclarationSyntax}} {{x}}(this string identifier)
              {
                  return {{SyntaxFactory}}.ClassDeclaration(identifier);
              }
              """),
        ("AddMembers",
            x=>$$"""
              public static {{CompilationUnitSyntax}} {{x}}(this {{CompilationUnitSyntax}} syntax, params {{String}}[] members)
              {
                  return syntax.AddMembers(members.Select(x => {{SyntaxFactory}}.ParseMemberDeclaration(x) ?? throw new global::System.Exception($"Text : {x} , Parse failed")).ToArray());
              }
              
              public static {{ClassDeclarationSyntax}} {{x}}(this {{ClassDeclarationSyntax}} syntax, params {{String}}[] members)
              {
                  return syntax.AddMembers(members.Select(x => {{SyntaxFactory}}.ParseMemberDeclaration(x) ?? throw new global::System.Exception($"Text : {x} , Parse failed")).ToArray());
              }
              """),
        ("AddUsings",
            x=>$$"""
              public static {{CompilationUnitSyntax}} {{x}}(this {{CompilationUnitSyntax}} syntax, params {{String}}[] usings)
              {
                  return syntax.AddUsings(usings.Select(x => {{SyntaxFactory}}.UsingDirective({{SyntaxFactory}}.ParseName(x))).ToArray());
              }
              """),
        ("AddNamespace",
            x=>$$"""
              public static {{CompilationUnitSyntax}} {{x}}(this {{CompilationUnitSyntax}} syntax, {{String}} @namespace)
              {
                  return syntax.AddMembers({{SyntaxFactory}}.NamespaceDeclaration({{SyntaxFactory}}.ParseName(@namespace)));
              }
              """),
        ("AddModifiers",
            x=>$$"""
              public static {{ClassDeclarationSyntax}} {{x}}(this {{ClassDeclarationSyntax}} syntax, params {{SyntaxKind}}[] items)
              {
                  return syntax.AddModifiers(items.Select(x => {{SyntaxFactory}}.Token(x)).ToArray());
              }
              """),
        ("AddBaseListTypes",
            x=>$$"""
              public static {{ClassDeclarationSyntax}} {{x}}(this {{ClassDeclarationSyntax}} syntax, params string[] identifiers)
              {
                  return syntax.AddBaseListTypes(identifiers.Select(x => {{SyntaxFactory}}.SimpleBaseType({{SyntaxFactory}}.IdentifierName(x))).ToArray());
              }
              """),
    };
#>
<#=Using#>
#nullable enable
namespace <#=NameSpace#>
{
    internal static class <#=ClassName#>Extensions
    {
<#foreach(var (name,text) in methods){#>
<#
      var target = text(name).Replace("\n", "\n        ");#>
        <#=target#>

	    internal const string <#=name#>Text =
        """
        
        <#=target#>
        """;

<#}#>
    }
}