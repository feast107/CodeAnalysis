<#@ template language="C#" #>
<#@ import namespace="System.Collections.Generic" #>
<#
    const string NameSpace = "Microsoft.CodeAnalysis";
    const string Using = """
                         using System.Linq;
                         """;
    const string String = "global::System.String";
    const string Bool = "global::System.Boolean";
    const string SyntaxNode = "global::Microsoft.CodeAnalysis.SyntaxNode";
    const string IEnumerable = "global::System.Collections.Generic.IEnumerable";
    const string IMethodSymbol = "global::Microsoft.CodeAnalysis.IMethodSymbol";
    const string SemanticModel = "global::Microsoft.CodeAnalysis.SemanticModel";
    const string SyntaxKind = "global::Microsoft.CodeAnalysis.CSharp.SyntaxKind";
    const string AttributeSyntax = "global::Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax";
    const string CompilationUnitSyntax = "global::Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax";
    const string LiteralExpressionSyntax = "global::Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax";
    const string AttributeArgumentSyntax = "global::Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax";
    const string MemberDeclarationSyntax = "global::Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax";
    const string LambdaExpressionSyntax = "global::Microsoft.CodeAnalysis.CSharp.Syntax.LambdaExpressionSyntax";
    const string BaseParameterSyntax = "global::Microsoft.CodeAnalysis.CSharp.Syntax.BaseParameterSyntax";
    const string StatementSyntax = "global::Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax";
    const string CancellationToken = "global::System.Threading.CancellationToken";
    const string NotSupported = "global::System.NotSupportedException";
    const string ClassName = "Syntax";
    
    var methods = new List<(string name,Func<string,string> text)>
    {
        ("GetAllAttributes",
            x=>$$"""
            public static {{IEnumerable}}<{{AttributeSyntax}}> {{x}}(this {{SyntaxNode}} syntax)
            {
                var attributeLists = syntax switch
                {
                    {{CompilationUnitSyntax}} compilationUnitSyntax     => compilationUnitSyntax.AttributeLists,
                    {{MemberDeclarationSyntax}} memberDeclarationSyntax => memberDeclarationSyntax.AttributeLists,
                    {{LambdaExpressionSyntax}} lambdaExpressionSyntax   => lambdaExpressionSyntax.AttributeLists,
                    {{BaseParameterSyntax}} baseParameterSyntax         => baseParameterSyntax.AttributeLists,
                    {{StatementSyntax}} statementSyntax                 => statementSyntax.AttributeLists,
                    _                                                                                            => throw new {{NotSupported}}($"{syntax.GetType()} has no attribute")
                };
                return attributeLists.SelectMany(attributeListSyntax => attributeListSyntax.Attributes);
            }
            """),
        ("GetSpecifiedAttributes",
            x=>$$"""
              public static {{IEnumerable}}<{{AttributeSyntax}}> {{x}}(this {{SyntaxNode}} syntax, 
                  {{SemanticModel}} semanticModel, 
                  {{String}} fullAttributeName, 
                  {{CancellationToken}} cancellationToken = default ({{CancellationToken}}))
              {
                  foreach (var attributeSyntax in syntax.GetAllAttributes())
                  {
                      if(cancellationToken.IsCancellationRequested)
                          yield break;
                      if (semanticModel.GetSymbolInfo(attributeSyntax, cancellationToken).Symbol is not {{IMethodSymbol}} attributeSymbol)
                          continue;
              
                      string attributeName = attributeSymbol.ContainingType.ToDisplayString();
              
                      if (attributeName == fullAttributeName)
                          yield return attributeSyntax;
                  }
              }
              """),
        ("GetSpecifiedAttribute",
            x=>$$"""
              public static {{AttributeSyntax}}? {{x}}(this {{SyntaxNode}} syntax, 
                  {{SemanticModel}} semanticModel, 
                  {{String}} fullAttributeName,
                  {{CancellationToken}} cancellationToken = default ({{CancellationToken}}))
              {
                  foreach (var attributeSyntax in syntax.GetSpecifiedAttributes(semanticModel, fullAttributeName, cancellationToken))
                  {
                      return attributeSyntax;
                  }
                  return null;
              }
              """),
        ("HasSpecifiedAttribute",
            x=>$$"""
              public static {{Bool}} {{x}}(this {{MemberDeclarationSyntax}} syntax, 
                  {{SemanticModel}} semanticModel, 
                  {{String}} fullAttributeName)
              {
                  return syntax.GetSpecifiedAttribute(semanticModel, fullAttributeName) is not null;
              }
              """),
        ("GetArgumentString",
            x=>$$"""
              public static {{String}}? {{x}}(this {{AttributeArgumentSyntax}} syntax)
              {
                  if (syntax.Expression is not {{LiteralExpressionSyntax}} literalExpressionSyntax) return null;
                  if (!literalExpressionSyntax.IsKind({{SyntaxKind}}.StringLiteralExpression)) return null;
                  return literalExpressionSyntax.Token.ValueText;
              }
              """)
        
    
    };
#>
<#=Using#>
#nullable enable
namespace <#=NameSpace#>
{
    internal static class <#=ClassName#>Extensions
    {
<#foreach(var (name,text) in methods){#>
<#
      var target = text(name).Replace("\n", "\n        ");#>
        <#=target#>

	    internal const string <#=name#>Text =
        """
        
        <#=target#>
        """;

<#}#>
    }
}