<#@ template language="C#" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#
    const string NameSpace = "Microsoft.CodeAnalysis";
    const string Using = """
                         using System.Linq;
                         """;
    const string String = "global::System.String";
    const string SyntaxValueProvider = "global::Microsoft.CodeAnalysis.SyntaxValueProvider";
    const string CancellationToken = "global::System.Threading.CancellationToken";
    const string ClassName = "SyntaxValueProvider";
    const string Bool = "global::System.Boolean";
    const string GeneratorAttributeSyntaxContext = "global::Microsoft.CodeAnalysis.GeneratorAttributeSyntaxContext";
    const string SyntaxNode = "global::Microsoft.CodeAnalysis.SyntaxNode";
    const string Func = "global::System.Func";
    const string IncrementalValuesProvider = "global::Microsoft.CodeAnalysis.IncrementalValuesProvider";
    var methods = new List<(string name,string text)>
    {
        ("ForAttributeWithMetadataName",
            $$"""
            public static {{IncrementalValuesProvider}}<T> ForAttributeWithMetadataName<T>(
                this {{SyntaxValueProvider}} syntaxValueProvider,
                {{String}} fullyQualifiedMetadataName,
                {{Func}}<{{SyntaxNode}}, {{CancellationToken}}, {{Bool}}> predicate,
                {{Func}}<{{GeneratorAttributeSyntaxContext}}, {{CancellationToken}}, T> transform)
            {
                return
                    syntaxValueProvider
                    .CreateSyntaxProvider(
                        predicate,
                        (context, token) =>
                        {
                            ISymbol? symbol = context.SemanticModel.GetDeclaredSymbol(context.Node, token);
            
                            // If the syntax node doesn't have a declared symbol, just skip this node. This would be
                            // the case for eg. lambda attributes, but those are not supported by the MVVM Toolkit.
                            if (symbol is null)
                            {
                                return null;
                            }
            
                            // Skip symbols without the target attribute
                            if (!symbol.TryGetAttributeWithFullyQualifiedMetadataName(fullyQualifiedMetadataName, out AttributeData? attributeData))
                            {
                                return null;
                            }
            
                            // Edge case: if the symbol is a partial method, skip the implementation part and only process the partial method
                            // definition. This is needed because attributes will be reported as available on both the definition and the
                            // implementation part. To avoid generating duplicate files, we only give priority to the definition part.
                            // On Roslyn 4.3+, ForAttributeWithMetadataName will already only return the symbol the attribute was located on.
                            if (symbol is IMethodSymbol { IsPartialDefinition: false, PartialDefinitionPart: not null })
                            {
                                return null;
                            }
            
                            // Create the GeneratorAttributeSyntaxContext value to pass to the input transform. The attributes array
                            // will only ever have a single value, but that's fine with the attributes the various generators look for.
                            GeneratorAttributeSyntaxContext syntaxContext = new(
                                targetNode: context.Node,
                                targetSymbol: symbol,
                                semanticModel: context.SemanticModel,
                                attributes: ImmutableArray.Create(attributeData));
            
                            return new Option<T>(transform(syntaxContext, token));
                        })
                    .Where(static item => item is not null)
                    .Select(static (item, _) => item!.Value)!;
            }
            """),
    };
#>
<#=Using#>
#nullable enable
namespace <#=NameSpace#>
{
    internal static class <#=ClassName#>Extensions
    {
<#foreach(var (name,text) in methods){#>
<#
      var target = text.Replace("\n", "\n        ");#>
        <#=target#>

	    internal const string <#=name#>Text =
        """
        
        <#=target#>
        """;

<#}#>
    }
}