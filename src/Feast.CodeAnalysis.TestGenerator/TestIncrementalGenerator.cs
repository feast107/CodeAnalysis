using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Text;
using Feast.CodeAnalysis.Extensions;
using G;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using TypeInfo = Feast.CodeAnalysis.Utils.TypeInfo;

namespace Feast.CodeAnalysis.TestGenerator
{
    /// <summary>
    /// A sample source generator that creates a custom report based on class properties. The target class should be annotated with the 'Generators.ReportAttribute' attribute.
    /// When using the source code as a baseline, an incremental source generator is preferable because it reduces the performance overhead.
    /// </summary>
    [Generator]
    public class TestIncrementalGenerator : IIncrementalGenerator
    {
        private const string Namespace     = "Generators";
        private const string AttributeName = "AnalyzeAttribute";

        private const string AttributeSourceCode =
            $$"""
               // <auto-generated/>

              namespace {{Namespace}}
              {
                  [System.AttributeUsage(System.AttributeTargets.Class)]
                  public class {{AttributeName}} : System.Attribute
                  {
                      public {{AttributeName}}(Type type){ }
                  }
              }
              """;


        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            context.RegisterPostInitializationOutput(x =>
            {
                x.AddSource($"{AttributeName}.g.cs", 
                    SourceText.From(AttributeSourceCode, Encoding.UTF8));
            });
            // Add the marker attribute to the compilation.
            var provider = context.SyntaxProvider.ForAttributeWithMetadataName(
                $"{Namespace}.{AttributeName}",
                (ctx, t) => ctx is ClassDeclarationSyntax,
                (ctx, t) => (ctx.TargetNode as ClassDeclarationSyntax)!);

            // Generate the source code.
            context.RegisterSourceOutput(context.CompilationProvider.Combine(provider.Collect()),
                (ctx, t) => GenerateCode(ctx, t.Left, t.Right));
        }

   
        /// <summary>
        /// Generate code action.
        /// It will be executed on specific nodes (ClassDeclarationSyntax annotated with the [Report] attribute) changed by the user.
        /// </summary>
        /// <param name="context">Source generation context used to add source files.</param>
        /// <param name="compilation">Compilation used to provide access to the Semantic Model.</param>
        /// <param name="classDeclarations">Nodes annotated with the [Report] attribute that trigger the generate action.</param>
        private void GenerateCode(SourceProductionContext context, Compilation compilation,
            ImmutableArray<ClassDeclarationSyntax> classDeclarations)
        {
            // Go through all filtered class declarations.
            foreach (var classDeclarationSyntax in classDeclarations)
            {
                var semanticModel = compilation.GetSemanticModel(classDeclarationSyntax.SyntaxTree);
                if (semanticModel.GetDeclaredSymbol(classDeclarationSyntax) is not INamedTypeSymbol classSymbol)
                    continue;
                var namespaceName = classSymbol.ContainingNamespace.ToDisplayString();
                var className     = classDeclarationSyntax.Identifier.Text;

                // Go through all class members with a particular type (property) to generate method lines.
                foreach (var prop in classSymbol
                             .GetMembers()
                             .OfType<IPropertySymbol>())
                {
                    var type = TypeInfo.FromSymbol(prop.Type);
                    var can  = typeof(Foo).IsAssignableTo(prop.Type);
                    Debugger.Break();
                }
    
            
                // Add the source code to the compilation.
                //context.AddSource($"{className}.g.cs", SourceText.From(code, Encoding.UTF8));
            }
        }
    
    }
}

namespace G
{
    public class Foo : Dictionary<Foo, string>
    {
    }

}
